package pit;

import java.io.Serializable;
import java.util.*;
import javax.jms.*;
import javax.jms.Queue;
import javax.naming.*;

/*
 * This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer.  Each PITplayer instantiates this model and uses it to
 * process the messages it receives. The monopoly strategy is used here as:
 * 1. The user set the monopoly card with the card with largest number the
 * user has when the user received the marker message.
 *
 * 2. Decide whether to accept the trade from other trader based on the trade card type whether
 * matches the monopoly card prior set. If match, accept it. If not, reject it.
 *
 * 3. Only sent the trade with the card with the least number the user current
 * have.
 *
 * 4. If reach monopoly stage, the user keeps playing the game by trading the
 * monopoly card of the user until the user hit the 20000 trade number.
 *
 * @author: Yan Xing andrewid: yanxing
 */
public class PITPlayerModel {

    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.
    private final int myPlayerNumber;
    // Cards is this player's set of cards.
    private final ArrayList cards = new ArrayList();
    // numTrades counts trades.
    private int numTrades = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 20000;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITsnapshot servlet
    private int numPlayers = 0;
    // halting indicates that the system is being reset, so ignore trades until a new had received
    private boolean halting = false;
    // record whether the snapshot start
    private boolean snapShotStart = false;
    // the hashset record the channels of the players that has already received
    private Set<Integer> receivedChannel = new HashSet<>();
    // the monoply card refers to the card with the maximum number the user has
    private String monoplyCard = null;

    /* The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
     * where the  object is a HashMap. Therefore this definition of HashMap is
     * provided although it  is not currently used (it is for you to use).
     * PITsnapshot is expecting a  set of attibute/value pairs. These include the player
     * number, as in state.put("Player",myPlayerNumber),  and each commodity string
     * and the number of that commodity  in the snapshot.
     * Also included below is a utility method  that will convert a HashMap into a string
     * which is useful for printing diagnostic messages to  the console.
     */
    private HashMap<String, Integer> state = new HashMap<>();

    /**
     * PITPlayerModel constructor saves what number player this object represents.
     *
     * @param myNumber the player number
     */
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;
    }

    /**
     * Send message.
     *
     * @param message the message sent
     */
    public void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                /*
                 * There are 6 types of messages:  Reset, NewHand, TenderOffer,
                 * AcceptOffer, RejectOffer, and Marker
                 */

                // Reset the Player.  This message is generated by the PITsnapshot servlet
                if (o instanceof Reset) {
                    doReset((Reset) o);

                    // NewHand received from PITsnapshot
                } else if (o instanceof NewHand) {
                    // Add the new hand into cards
                    doNewHand((NewHand) o);

                    // Receive an offer from another Player
                } else if (o instanceof TenderOffer) {
                    doReceiveTenderOffer((TenderOffer) o);

                    // Another Player accepted our offer
                } else if (o instanceof AcceptOffer) {
                    doReceiveAcceptOffer((AcceptOffer) o);

                    // Another Player rejected our offer
                } else if (o instanceof RejectOffer) {
                    doReceiveRejectOffer((RejectOffer) o);

                    // process the marker
                } else if (o instanceof Marker) {
                    doMarker((Marker) o);
                } else {
                    System.out.println("PITplayer" + myPlayerNumber + " received unknown Message type");
                    // just ignore it
                }
            }
        } catch (Exception e) {
            System.out.println("Exception thrown in PITplayer" + myPlayerNumber + ": " + e);
        }
    }

    /**
     * Process the marker message. Set the monopoly card as soon as the player get the marker.
     *
     * @param marker the marker object
     * @throws Exception the exception
     */
    private void doMarker(Marker marker) throws Exception {
        // get the source player of the marker
        int source = marker.source;
        // if not received, add it to the receivedChannel
        if (source != -1) {
            receivedChannel.add(source);
        }

        // start snap shot
        if (!snapShotStart) {
            // record the number of the cards current the player has
            for (Object card : cards) {
                // get the card
                String cardString = (String) card;
                // get the number of the card, if not found, get as 0
                int number = state.getOrDefault(cardString, 0);
                // increase the number by one
                number++;
                // up the card and number into state
                state.put(cardString, number);
            }

            // broadcast the marker to every player expect the current player himself
            for (int i = 0; i < numPlayers; i++) {
                // skip the current player
                if (i != myPlayerNumber) {
                    //Send the marker to the other player
                    String sendToJNDI = "openejb:Resource/PITplayer" + i;
                    sendToQueue(sendToJNDI, new Marker(myPlayerNumber));
                }
            }
            // set the snapshot is start
            snapShotStart = true;
            // get the monopoly card of the user
            // the monoply card refers to the card with the maximum number the user has
            setTheMonopolyCard();
        }

        // if received all markers from all other channels
        if (receivedChannel.size() == numPlayers - 1) {
            // put the player number
            state.put("Player", myPlayerNumber);
            // send to the snap shot
            sendToQueue("openejb:Resource/PITsnapshot", state);
            // reset the state
            state.clear();
            snapShotStart = false;
            receivedChannel.clear();
        }
    }

    /**
     * Do the reset message.
     *
     * @param reset the reset message
     * @throws Exception exception
     */
    private void doReset(Reset reset) throws Exception {
        // Resetting is done by two messages, first to halt, then to clear
        if (reset.action == Reset.HALT) {
            System.out.println("PITplayer" + myPlayerNumber + " received Reset HALT");
            halting = true;
            // Reply to the PITsnapshot servlet acknowledging the Reset HALT
            sendToQueue("openejb:Resource/PITmonitor", reset);
        } else { // action == Reset.CLEAR
            System.out.println("PITplayer" + myPlayerNumber + " received Reset RESET");
            // Drop all cards in hand
            cards.clear();
            numTrades = 0;
            numPlayers = 0;
            halting = false;
            // Reply to the PITsnapshot servlet acknowledging the Reset
            sendToQueue("openejb:Resource/PITmonitor", reset);
        }
    }

    /**
     * Process the new hand message.
     *
     * @param hand the new hand message
     * @throws Exception exception
     */
    private void doNewHand(NewHand hand) throws Exception {
        // Add a new hand of cards.
        // It is actually possible that an offer from another Player has been
        // accepted already, beating the NewHand
        cards.addAll((hand).newHand);
        numPlayers = (hand).numPlayers;
        System.out.println("PITplayer" + myPlayerNumber + " new hand: " + toString(cards));
        // Offer a card to another Player
        doTenderOffer();
    }

    /**
     * Decide weather to accept the trade based on the trade card type whether matches the monopoly card prior set.
     *
     * @param trade the trade offer
     * @throws Exception exception
     */
    private void doReceiveTenderOffer(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }

        System.out.println("PITplayer" + myPlayerNumber + " received offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);

        // When receiving an offer, decide whether to Accept or Reject it
        // get player number
        int source = trade.sourcePlayer;

        // if the card match the monopoly card
        if (decideWithMonoply(trade.tradeCard)) {
            // Accept the trade

            // Add the Offer to my hand of cards
            cards.add(trade.tradeCard);

            // Pay with one of my cards
            doReplyAccept(trade.sourcePlayer);

        } else {
            /* Otherwise reject the offer and send back the card */

            doReplyReject(trade);
        }

        // Snapshot have started and there is no receive from source player
        // update state
        if (!receivedChannel.contains(source) && snapShotStart) {
            // get the card from trade
            String cardString = trade.tradeCard;
            // get the card from state, if not found, get as 0
            int num = state.getOrDefault(cardString, 0);
            // add the number by 1
            num++;
            // put the new number into state
            state.put(cardString, num);
        }

    }

    /**
     * Choose to accept the trade. Send the accepting message through the queue.
     *
     * @param sendTo the sent player
     * @throws Exception the exception
     */
    private void doReplyAccept(int sendTo) throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // In payment for the card I just accepted, send back one of my cards.
        AcceptOffer newTrade = new AcceptOffer();

        // get the card with least number the player current have
        String leastCard = getLeastCard();

        // if the least card can not found
        if (leastCard.equals("N/A")) {
            // just remove the first element
            // set the trade card with the element removed
            newTrade.tradeCard = (String) cards.remove(0);
        } else {
            // remove the least card from the cards array
            cards.remove(leastCard);
            // set the trade card with the element removed
            newTrade.tradeCard = leastCard;
        }

        // set the trading player number
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " accepting offer and paying with: " + newTrade.tradeCard + " to player: " + sendTo);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        String sendToJNDI = "openejb:Resource/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    /**
     * Reply rejecting an offer that was received. Send back their card.
     *
     * @param trade the trade offer
     * @throws Exception exception
     */
    private void doReplyReject(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }

        System.out.println("PITplayer" + myPlayerNumber + " rejecting offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // Send back their card that I am rejecting
        RejectOffer newTrade = new RejectOffer();
        newTrade.tradeCard = trade.tradeCard;
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        String sendToJNDI = "openejb:Resource/PITplayer" + trade.sourcePlayer;
        sendToQueue(sendToJNDI, newTrade);

    }

    /**
     * Handle receiving a message that a previous offer has been accepted.
     * They would have replied with another card as payment.
     *
     * @param trade the trade offer
     * @throws Exception the exception
     */
    private void doReceiveAcceptOffer(AcceptOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Having received a AcceptOffer from another Player, add it to my hand of cards
        cards.add(trade.tradeCard);


        // get player number
        int source = trade.sourcePlayer;

        // Snapshot have started and there is no receive from source player
        // update state
        if (!receivedChannel.contains(source) && snapShotStart) {
            // get the card from trade
            String cardString = trade.tradeCard;
            // get the card from state, if not found, get as 0
            int num = state.getOrDefault(cardString, 0);
            // add the number by 1
            num++;
            // put the new number into state
            state.put(cardString, num);
        }

        System.out.println("PITplayer" + myPlayerNumber + " received: " + trade.tradeCard + " as payment from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Make another offer to a random player
        doTenderOffer();
    }

    /**
     * Handle receiving a reject message regarding a prior offer I made
     *
     * @param trade the reject offer
     * @throws Exception the exception
     */
    private void doReceiveRejectOffer(RejectOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Because the offer was rejected, and returned, add it back into my cards
        cards.add(trade.tradeCard);

        // get player number
        int source = trade.sourcePlayer;

        // Snapshot have started and there is no receive from source player
        // update state
        if (!receivedChannel.contains(source) && snapShotStart) {
            // get the card from trade
            String cardString = trade.tradeCard;
            // get the card from state, if not found, get as 0
            int num = state.getOrDefault(cardString, 0);
            // add the number by 1
            num++;
            // put the new number into state
            state.put(cardString, num);
        }

        System.out.println("PITplayer" + myPlayerNumber + " received rejected offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Make another offer to a random player
        doTenderOffer();
    }

    /**
     * Make an offer trade to a random player. Only make the trade with the card with the least number the user current
     * have.
     *
     * @throws Exception the exception
     */
    private void doTenderOffer() throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        /*
         * If numPlayers == 0, while we have received a TenderOffer, we have not
         * received our NewHand yet, so we don't know how many players there
         * are.  Therefore, don't send out a TenderOffer at this time.
         *
         */
        if (numPlayers == 0) {
            return;
        }

        // Create a new offer from my set of cards, and send to another player
        TenderOffer newTrade = new TenderOffer();

        // get the card with least number the player current have
        String leastCard = getLeastCard();

        // if the least card can not found
        if (leastCard.equals("N/A")) {
            // just remove the first element
            // set the trade card with the element removed
            newTrade.tradeCard = (String) cards.remove(0);
        } else {
            // remove the least card from the cards array
            cards.remove(leastCard);
            // set the trade card with the element removed
            newTrade.tradeCard = leastCard;
        }

        // set the trading player number
        newTrade.sourcePlayer = myPlayerNumber;


        // Find a random player to trade to (not including myself)
        int sendTo = myPlayerNumber;
        while (sendTo == myPlayerNumber) {
            sendTo = Math.round((float) Math.random() * (numPlayers - 1));
        }

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " offered: " + newTrade.tradeCard + " to player: " + sendTo);
        String sendToJNDI = "openejb:Resource/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);

    }

    /**
     * Create a string of hand size and all cards
     *
     * @param hand the hand array list
     * @return a string of hand size and all cards
     */
    private String toString(ArrayList hand) {

        String cardsString = "size: " + hand.size() + " ";
        for (int i = 0; i < hand.size(); i++) {
            cardsString += hand.get(i) + " ";
        }
        return cardsString;
    }

    /**
     * Create a printable version of the "state".
     *
     * @param state the state
     * @return a printable version of the "state"
     */
    private String toString(HashMap<String, Integer> state) {
        String stateString = "";
        for (Iterator it = state.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            String commodity = (String) entry.getKey();
            int number = ((Integer) entry.getValue()).intValue();
            stateString += "{" + commodity + ":" + number + "} ";
        }
        return stateString;
    }

    /**
     * Send an object to a Queue, given its JNDI name
     *
     * @param queueJNDI queueJNDI
     * @param message   the message sent
     * @throws Exception exception
     */
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctxt = new InitialContext();
        Connection con = ((ConnectionFactory) ctxt.lookup("openejb:Resource/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctxt.lookup(queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctxt.close();
    }

    /**
     * Stop trading when the max number of Trades is reached
     *
     * @param max the max trade number
     * @return whether stop trading
     */
    private boolean maxTrades(int max) {
        if ((numTrades % 100) == 0) {
            System.out.println("PITplayer" + myPlayerNumber + " numTrades: " + numTrades);
        }
        return (numTrades++ < max) ? false : true;
    }

    /**
     * Whether the input card match the monopoly card.
     *
     * @param tradeCard the input card
     * @return whether the input card match the monopoly card
     */
    private boolean decideWithMonoply(String tradeCard) {
        // if match, return true
        if (tradeCard.equals(monoplyCard)) {
            return true;
        }
        // if not, return false
        return false;
    }

    /**
     * Set the monopoly card as the card with the largest number the current user has.
     */
    private void setTheMonopolyCard() {
        // get the most cards the current user has
        String mostCard = null;
        // the max value to found the card
        int maxCount = Integer.MIN_VALUE;

        // iterate through the cards in the state
        for (String card : state.keySet()) {
            // if user has the card
            if (cards.contains(card)) {
                // get the card number
                int count = state.get(card);
                // if the card number is smaller than maxCount
                if (count > maxCount) {
                    // update the minCount
                    maxCount = count;
                    // update the most card name
                    mostCard = card;
                }
            }
        }
        // return the most card
        monoplyCard = mostCard;
    }

    /**
     * Get the card with the least number the current user has.
     *
     * @return the card string with least number
     */
    private String getLeastCard() {
        // get the least cards the current user has
        String leastCard = null;
        // the min value to found the card
        int minCount = Integer.MAX_VALUE;

        // iterate through the cards in the state
        for (String card : state.keySet()) {
            // if user has the card
            if (cards.contains(card)) {
                // get the card number
                int count = state.get(card);
                // if the card number is smaller than minCount
                if (count < minCount) {
                    // update the minCount
                    minCount = count;
                    // update the least card name
                    leastCard = card;
                }
            }
        }

        // if the least card is not found
        if (leastCard == null) {
            // return N/A
            return "N/A";
        }
        // return the least card
        return leastCard;
    }
}
